# Document 44: NanoBanana API Integration for D&D Asset Generation

## Purpose

This document specifies how to integrate **NanoBanana API** (powered by Google Gemini image models) into the D&D Digital Board Game platform for generating high-quality:

- Character portraits (head/shoulders)
- Full-body character images (heroic pose)
- Action pose images (combat stance)
- Location/scene art
- Monster illustrations
- Item/equipment images

---

# PART 1: CURRENT IMPLEMENTATION STATUS

## 1.1 What is Implemented

| Feature | Status | Details |
|---------|--------|---------|
| Character Portrait Generation | ✅ Complete | Head/shoulders portrait with 1:1 aspect ratio |
| Full-Body Generation | ✅ Complete | Heroic standing pose with 2:3 aspect ratio |
| Action Pose Generation | ✅ Complete | Dynamic combat pose with 2:3 aspect ratio |
| 3-Image Character Cards | ✅ Complete | Generate all 3 images per character |
| User Generation Limits | ✅ Complete | 5 characters (15 images) per user |
| Webhook Callback | ✅ Complete | Async image generation with callback |
| DiceBear Fallback | ✅ Complete | Fallback when API fails or not configured |
| Character Card Modal | ✅ Complete | Trading card style with carousel |

## 1.2 API Configuration

```env
# Required environment variables
NANOBANANA_API_KEY=your_api_key_here
CALLBACK_BASE_URL=https://your-api-domain.com
```

## 1.3 Cost Structure

| Model | Cost | Used For |
|-------|------|----------|
| NanoBanana Standard | ~$0.04/image | All character images |
| Per Character | ~$0.12 | 3 images (portrait + 2 full-body) |
| Per User Limit | ~$0.60 max | 5 characters × 3 images |

---

# PART 2: ACTUAL API ENDPOINTS

## 2.1 Generate All Character Images

**POST** `/media/generate/character-images`

Generates all 3 character images at once (portrait, heroic pose, action pose).

```typescript
// Request
interface CharacterImagesRequest {
  character: {
    race: string;      // human, elf, dwarf, etc.
    class: string;     // fighter, wizard, rogue, etc.
    background?: string;
    name?: string;
    appearance?: {
      hairColor?: string;
      hairStyle?: string;
      eyeColor?: string;
      skinTone?: string;
    };
  };
  quality?: 'standard' | 'high';  // default: standard
}

// Response
interface CharacterImagesResponse {
  success: boolean;
  images: {
    portrait: string;    // Head/shoulders (1:1)
    fullBody1: string;   // Heroic pose (2:3)
    fullBody2: string;   // Action pose (2:3)
  };
  source: 'nanobanana' | 'fallback';
  imagesGenerated: number;  // Number of AI images (0-3)
  generated: number;        // Total characters generated by user
  remaining: number;        // Characters remaining in user's limit
}

// Error Response (limit reached)
interface LimitReachedResponse {
  success: false;
  error: string;
  limitReached: true;
  generated: number;
  limit: number;
}
```

## 2.2 Check Generation Limit

**GET** `/media/generation-limit`

Check user's remaining AI generation quota.

```typescript
// Response
interface GenerationLimitResponse {
  success: boolean;
  generated: number;   // Characters already generated
  remaining: number;   // Characters remaining
  limit: number;       // Total limit (5)
}
```

## 2.3 Legacy Single Portrait

**POST** `/media/generate/portrait`

Legacy endpoint for single image generation (doesn't count against limit).

```typescript
// Request
interface PortraitRequest {
  character: {
    race: string;
    class: string;
    background?: string;
    name?: string;
  };
  style?: 'portrait' | 'full_body' | 'action_pose';
  quality?: 'standard' | 'high';
}

// Response
interface PortraitResponse {
  success: boolean;
  imageUrl: string;
  source: 'nanobanana' | 'fallback';
}
```

## 2.4 NanoBanana Webhook

**POST** `/media/webhook/nanobanana`

Webhook endpoint called by NanoBanana when image generation completes.

```typescript
// NanoBanana Webhook Request Body
interface NanoBananaWebhook {
  code: number;          // 200 = success
  msg: string;           // Status message
  data: {
    taskId: string;
    info: {
      resultImageUrl: string;  // The generated image URL
    };
  };
}
```

---

# PART 3: PROMPT ENGINEERING

## 3.1 Character Portrait Prompt Structure

The system builds detailed prompts based on race, class, and style:

```typescript
// Prompt building function in media.ts
function buildCharacterPrompt(character, style): { prompt: string; negativePrompt: string } {
  // Art style (consistent D&D aesthetic)
  const artStyle = [
    'official Dungeons and Dragons artwork',
    'by Larry Elmore',
    'by Todd Lockwood',
    'Players Handbook cover art quality',
    'epic fantasy book cover art',
    'traditional oil painting technique',
    'rich color palette with deep shadows',
  ].join(', ');

  // Composition based on style
  let composition: string;
  if (style === 'portrait') {
    composition = 'portrait, head and shoulders, close-up face shot, detailed facial features, expressive eyes, three-quarter view, dramatic lighting on face, shallow depth of field background';
  } else if (style === 'action_pose') {
    composition = 'dynamic action pose, mid-combat stance, weapon raised, dramatic motion blur on edges, intense expression';
  } else {
    composition = 'full body character design, standing heroic pose, weight on back foot ready for action, head to toe visible, facing three-quarter view';
  }

  // Race-specific features (elf, dwarf, tiefling, etc.)
  const raceDescription = getRaceDescription(character.race);

  // Class-specific appearance (armor, weapons, robes)
  const classAppearance = getClassAppearance(character.class);

  // Environment/background
  const background = 'dramatic fantasy environment, torch-lit stone dungeon walls, mystical fog at feet, volumetric god rays';

  // Build final prompt
  const prompt = `${artStyle}, ${composition}, ${raceDescription}, ${classAppearance}, ${background}`;

  // Negative prompt for safety and quality
  const negativePrompt = 'nude, naked, nsfw, sexual, gore, blood, violent, deformed, ugly, blurry, low quality, bad anatomy, watermark, signature';

  return { prompt, negativePrompt };
}
```

## 3.2 Race Descriptions

```typescript
const raceDescriptions = {
  human: 'human, realistic proportions, noble bearing, determined expression',
  elf: 'elf, pointed ears, elegant angular features, ethereal beauty, ageless appearance, almond-shaped eyes',
  dwarf: 'dwarf, stocky muscular build, magnificent braided beard, rugged weathered features, proud stance',
  halfling: 'halfling, small stature three feet tall, youthful cheerful face, curly hair, bare hairy feet',
  dragonborn: 'dragonborn, reptilian humanoid, scaled skin, draconic head with snout, powerful muscular build, no tail',
  tiefling: 'tiefling, demonic curved horns, solid colored eyes without pupils, pointed tail, infernal heritage visible',
  gnome: 'gnome, very small stature, large curious sparkling eyes, pointed nose, wild unkempt hair',
  'half-elf': 'half-elf, slightly pointed ears, blend of human and elven grace, versatile attractive features',
  'half-orc': 'half-orc, muscular imposing build, prominent lower tusks, grayish-green skin, fierce expression',
};
```

## 3.3 Class Appearances

```typescript
const classAppearances = {
  fighter: 'battle-hardened warrior, wearing practical plate armor with battle damage, longsword and shield, military posture, scarred veteran appearance',
  wizard: 'scholarly arcane master, wearing elegant embroidered robes with mystical symbols, carrying ornate wooden staff topped with crystal, spell component pouch, ancient tome',
  rogue: 'shadowy infiltrator, wearing dark leather armor designed for stealth, hooded cloak obscuring face, multiple hidden daggers, lockpicks visible',
  cleric: 'divine champion, wearing polished chainmail with religious vestments, prominent holy symbol glowing with divine light, mace and shield bearing deity emblem',
  // ... more classes
};
```

---

# PART 4: FRONTEND IMPLEMENTATION

## 4.1 Character Card Modal

The character card displays in a trading card style with 3-image carousel:

```tsx
// CharacterCardModal features:
// - Portrait label on current image
// - Left/right navigation arrows
// - Dot indicators at bottom
// - Smooth slide animations between images
// - Character traits displayed below image
// - Decorative corner accents

interface CharacterImages {
  portrait: string;      // Head/shoulders image
  fullBody1: string | null;  // Heroic pose
  fullBody2: string | null;  // Action pose
}

const imageList = [
  { url: images.portrait, label: 'Portrait' },
  { url: images.fullBody1, label: 'Heroic Pose' },
  { url: images.fullBody2, label: 'Action Pose' },
];
```

## 4.2 Generation Flow

```tsx
const handleGenerateAIPortrait = async () => {
  setIsGeneratingPortrait(true);

  const response = await api.post('/media/generate/character-images', {
    character: {
      race: character.race,
      class: character.class,
      background: character.background,
      name: name || undefined,
    },
    quality: 'standard',
  });

  if (response.limitReached) {
    alert(`You have reached the limit of ${response.limit} AI-generated characters.`);
    return;
  }

  if (response.success && response.images) {
    setCharacterImages({
      portrait: response.images.portrait,
      fullBody1: response.images.fullBody1 || null,
      fullBody2: response.images.fullBody2 || null,
    });

    if (response.source === 'nanobanana') {
      setIsAIPortrait(true);
    }
  }

  setIsGeneratingPortrait(false);
};
```

## 4.3 UI States

| State | Display |
|-------|---------|
| Default | DiceBear avatar with "New", "Style", "AI Portrait" buttons |
| Generating | Spinner overlay with "Generating..." text |
| AI Portrait Active | AI image, "Regenerate" and "Reset" buttons, clickable for card |
| Limit Reached | Alert message, "AI character limit reached" warning |

---

# PART 5: STATIC PREVIEW IMAGES

## 5.1 Configuration

Static images for race/class/background selection are configured in:

```typescript
// apps/web/src/data/staticImages.ts

export const RACE_IMAGES: Record<string, string> = {
  human: 'URL_TO_HUMAN_IMAGE',
  elf: 'URL_TO_ELF_IMAGE',
  // ... etc
};

export const CLASS_IMAGES: Record<string, string> = {
  fighter: 'URL_TO_FIGHTER_IMAGE',
  wizard: 'URL_TO_WIZARD_IMAGE',
  // ... etc
};

export const BACKGROUND_IMAGES: Record<string, string> = {
  acolyte: 'URL_TO_ACOLYTE_IMAGE',
  criminal: 'URL_TO_CRIMINAL_IMAGE',
  // ... etc
};
```

Currently using DiceBear placeholders. To replace with AI-generated images:
1. Generate images using NanoBanana for each race/class/background
2. Upload to CDN or permanent storage
3. Update URLs in `staticImages.ts`

---

# PART 6: DATABASE SCHEMA

## 6.1 User AI Generation Tracking

```prisma
model User {
  // ... other fields

  // AI Generation limits
  aiCharactersGenerated Int @default(0)  // Max 5 characters (15 images)
}
```

---

# PART 7: DEPLOYMENT CONFIGURATION

## 7.1 Railway Environment Variables

Required on API service:
- `NANOBANANA_API_KEY` - Your NanoBanana API key
- `CALLBACK_BASE_URL` - Full HTTPS URL of your API (e.g., `https://api-production-xxx.up.railway.app`)
- `DATABASE_URL` - PostgreSQL connection string

## 7.2 Webhook Flow

```
1. Client → POST /media/generate/character-images
2. API → POST NanoBanana /generate with callBackUrl
3. NanoBanana → Processing image...
4. NanoBanana → POST {CALLBACK_BASE_URL}/media/webhook/nanobanana
5. API → Resolves pending promise with image URL
6. API → Returns response to client
```

## 7.3 Timeout Handling

- NanoBanana webhook timeout: 50 seconds
- If webhook doesn't arrive in time, falls back to DiceBear

---

# PART 8: CONTENT SAFETY

## 8.1 Prompt Safety

All prompts include mandatory safety terms:
- Positive: "fully clothed, appropriate fantasy armor and attire, heroic pose, professional illustration, family friendly"
- Negative: "nude, naked, nsfw, sexual, suggestive, revealing clothing, gore, blood, violent, disturbing, deformed, ugly, blurry, low quality"

## 8.2 Response Validation

Images from NanoBanana go through their content moderation before being returned.

---

**END OF DOCUMENT 44**
